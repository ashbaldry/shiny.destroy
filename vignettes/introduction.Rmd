---
title: "Removing Shiny Objects"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Removing Shiny Objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

As shiny applications become larger and more complex, there are requirements to dynamically show inputs, results and even entire modules. Functionality exists to be able to dynamically update the UI and server, however when removing the UI, traces of the input are still available throughout the application which may cause some unexpected behaviour. The aim of {shiny.destroy} is to eliminate all traces of the removed UI in the shiny application, providing the assurance that only the required observers and outputs are rendered after removal.

## UI

The front-end part of shiny inputs can easily be removed by using the `removeUI` function, however this does not impact the server side, where the input is still accessible. 

```{r basic_ui}
library(shiny)

ui <- fluidPage(
  numericInput("number", "Select number:", 5, 1, 10),
  actionButton("delete", "Remove input"),
  p("Selected number:", textOutput("number_out", inline = TRUE))
)

server <- function(input, output, session) {
  output$number_out <- renderText(input$number)
  
  observeEvent(input$delete, removeUI("#number"))
}

shinyApp(ui, server)
```

[Shiny application removing the numeric input with removeUI](./introduction_clips/removeUI.gif)

With `removeInput`, both the front and back end remove the input, and any observer or output that references the removed input will be updated. Whilst the trick of using `.subset2(input, "impl")$remove(id)` is known to remove the input, it does not trigger anything. Within the `input` object, the names are all stored within the `.namesOrder` and needs to be removed from here too.

After the input has been removed, the session needs to be aware that the input has been removed, otherwise nothing will be updated. This is where the invalidation of the various values is required, referencing the names and value dependency environments within the input object.

With all this resolved, the input is now fully removed from the shiny instance.

```{r destroy_ui}
library(shiny)
library(shiny.destroy)

ui <- fluidPage(
  numericInput("number", "Select number:", 5, 1, 10),
  actionButton("delete", "Remove input"),
  p("Selected number:", textOutput("number_out", inline = TRUE))
)

server <- function(input, output, session) {
  output$number_out <- renderText(input$number %||% "input unavailable")
  
  observeEvent(
    input$delete, 
    removeInput("number", selector = ":has(> #number)")
  )
}

shinyApp(ui, server)
```

[Shiny application removing the numeric input with removeInput](./introduction_clips/removeInput.gif)

## Server


## Module

In larger shiny applications, modules are beneficial to reduce the application down into smaller, reusable chunks. There are situations where these modules can be dynamically added to the application, but also want to be removed. By using `removeUI`, we can remove the HTML of the module, however there are still a load of server-side processes that will be running even with the module "removed". {shiny.destroy} makes sure that any trace of the module is no longer available within the application.

```{r module_example}
shiny::runExample(
  "01_boxes",
  package = "shiny.destroy"
)
```
